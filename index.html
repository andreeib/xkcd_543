<!DOCTYPE html5>
<html>
	<head>
		<title>XKCD 543 - Sierpinski Valentine</title>
		<style>
			* {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}
			body{
				padding: 50px;
				box-sizing: border-box;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas"></canvas>
	</body>
	<script type="text/javascript">

		"use strict";

		function vAdd (any_number_of_vectors) {

			var result = [0, 0];

			for (var i = 0; i < arguments.length; i++) {

				result[0] += arguments[i][0];
				result[1] += arguments[i][1];
			}

			return result;
		}

		function vSub (a, b) {

			return [a[0] - b[0], a[1] - b[1]];
		}

		function vsMul (v, s) {

			return [v[0] * s, v[1] * s];
		}

		function coordBarycentricToCartesian (triangle, b) {

			return vAdd(
				vsMul(triangle[0], b[0]),
				vsMul(triangle[1], b[1]),
				vsMul(triangle[2], b[2])
			);
		}

		function pathBarycentricToCartesian (triangle, path) {

			return path.map(function (bezier) {

				return bezier.map(function (b) {

					return coordBarycentricToCartesian(triangle, b);
				});
			});			
		}

		function flatten (arrayOfArrays) {

			return arrayOfArrays.reduce(function (soFar, current) {

				return soFar.concat(current);

			}, []);
		}

		function mirrorBarycentric (b) {

			return [b[0], b[2], b[1]];
		}

		var canvas = document.getElementById('canvas');
		var ctx = canvas.getContext('2d');

		var pixelDensity = window.devicePixelRatio;
		var lineWidth = 2 * pixelDensity;
		var canvasSize = [
			canvas.clientWidth  * pixelDensity,
			canvas.clientHeight * pixelDensity
		];
		canvas.setAttribute('width',  canvasSize[0]);
		canvas.setAttribute('height', canvasSize[1]);

		ctx.strokeStyle = "red";

		var triangleHeightFactor = Math.sqrt(.75);
		var triangleSize = [
			Math.min(canvasSize[0], canvasSize[1] / triangleHeightFactor) - 2 * lineWidth,
			Math.min(canvasSize[1], canvasSize[0] * triangleHeightFactor) - 2 * lineWidth
		];
		var margin = vsMul(vSub(canvasSize, triangleSize), 1/2);
		var triangle = [
			vAdd(margin, [triangleSize[0]/2, 0              ]),
			vAdd(margin, [triangleSize[0]  , triangleSize[1]]),
			vAdd(margin, [0                , triangleSize[1]])
		];


		ctx.beginPath();
		ctx.lineWidth = lineWidth;
		ctx.moveTo.apply(ctx, triangle[0]);
		triangle.slice(1).forEach(function (coord) {
			ctx.lineTo.apply(ctx, coord);
		});
		ctx.lineTo.apply(ctx, triangle[0]);
		ctx.stroke();


		var bezierBaseTriangleBarycentric = [
			// [1, 0, 0],
			[-1, 1, 1],
			[2/3, 1/3 , 0],
			[1/3, 2/3 , 0],
			[0, 1 , 0],
			[0, 2/3 , 1/3],
			[0, 1/3 , 2/3],
			[0, 0 , 1],
			[1/3, 0 , 2/3],
			[2/3, 0 , 1/3]
		]



		var heartRightUpper = [
			[
				1/2,
				1/4,
				1/4
			],
			[
				13/20,
				5/20,
				2/20
			],
			[
				6/10,
				4/10,
				0
			],
			[
				1/2,
				1/2,
				0
			],
		];

		var heartRightLower = [
			[
				1/2,
				1/2,
				0
			],
			[
				4/10,
				6/10,
				0
			],
			[
				3/16,
				10/16,
				3/16
			],
			[
				0,
				1/2,
				1/2
			]
		];


		var heartBarycentricBezier = [
			heartRightUpper,
			heartRightLower,
			heartRightLower.map(mirrorBarycentric),
			heartRightUpper.map(mirrorBarycentric)
		];



		drawPath(transformPathByTriangle(bezierBaseTriangleBarycentric, heartBarycentricBezier));


		function drawPath (path) {

			ctx.beginPath();
			ctx.lineWidth = lineWidth;
			pathBarycentricToCartesian(triangle, path).forEach(function (bezier) {

				ctx.moveTo.apply(ctx, bezier[0]);
				ctx.bezierCurveTo.apply(ctx, flatten(bezier.slice(1)));
			});
			ctx.stroke();
		}


		function transformPathByTriangle (triangle, path) {

			return path.map(function (bezier) {

				return bezier.map(function (b) {

					return evaluateBezierTriangle(triangle, b);
				});
			});			
		}

		function evaluateBezierTriangle (triangle, b) {

			var center = bAvg(
				triangle[1],
				triangle[2],
				triangle[4],
				triangle[5],
				triangle[7],
				triangle[8]
			);

			var subTriangles = [
				[triangle[0], triangle[1], triangle[8]],
				[triangle[1], triangle[2], center     ],
				[triangle[2], triangle[3], triangle[4]],
				[center     , triangle[4], triangle[5]],
				[triangle[7], triangle[5], triangle[6]],
				[triangle[8], center     , triangle[7]]
			];

			return evaluateBarycentricTriangle([
				evaluateBarycentricTriangle([
					evaluateBarycentricTriangle(subTriangles[0], b),
					evaluateBarycentricTriangle(subTriangles[1], b),
					evaluateBarycentricTriangle(subTriangles[5], b)
				], b),
				evaluateBarycentricTriangle([
					evaluateBarycentricTriangle(subTriangles[1], b),
					evaluateBarycentricTriangle(subTriangles[2], b),
					evaluateBarycentricTriangle(subTriangles[3], b)
				], b),
				evaluateBarycentricTriangle([
					evaluateBarycentricTriangle(subTriangles[5], b),
					evaluateBarycentricTriangle(subTriangles[3], b),
					evaluateBarycentricTriangle(subTriangles[4], b)
				], b)
			], b);
		}

		function bAvg (any_number_of_coords) {

			var result = [0, 0, 0];

			for (var i = 0; i < arguments.length; i++) {

				result[0] += arguments[i][0];
				result[1] += arguments[i][1];
				result[2] += arguments[i][2];
			};

			result[0] /= arguments.length;
			result[1] /= arguments.length;
			result[2] /= arguments.length;

			return result;
		}

		function evaluateBarycentricTriangle (triangle, b) {

			return [
				triangle[0][0] * b[0] +
				triangle[1][0] * b[1] +
				triangle[2][0] * b[2],
				triangle[0][1] * b[0] +
				triangle[1][1] * b[1] +
				triangle[2][1] * b[2],
				triangle[0][2] * b[0] +
				triangle[1][2] * b[1] +
				triangle[2][2] * b[2]
			];
		}


	</script>
</html>
